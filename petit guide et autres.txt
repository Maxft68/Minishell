
en premier soi redirection "< > " soit commande

enregistrer le code error dans une structure pour pouvoir le resortir avec $? meme si code erreur succes

echo coucou > outfile1 >outfile2 > outfile3 : coucou ne sera que dans outfile3 
mais outfile 1 et 2 seront creer
idem pour les infile, mais si infile1 echoue alors tout sarrete 
et ne va meme pas voir infile2

cat <in1 >out1 >out2 <in2 = in2 ira dans out2 et out1 supprimer

"cat <in <in2 | cat >out"

noeud 1
command "cat" "arg1" "arg2" ...
redir sign <
		name in
	sign <
	name in2  
noeud 2
command cat 
	redir
	name out 
	sign >



si | present alors executer les built-in uniquement dans les enfants


echo hello world from minishell

Tu dois tous les stocker dans t_cmd->argv, comme ceci :

argv[0] = "echo";
argv[1] = "hello";
argv[2] = "world";
argv[3] = "from";
argv[4] = "minishell";
argv[5] = NULL;

cat < input.txt > output.txt

‚û°Ô∏è Une seule commande, avec :

    argv = ["cat", NULL]

    redir 1 = < input.txt

    redir 2 = > output.txt

Si current token = | et (le pr√©c√©dent est | ou c‚Äôest le premier ou le dernier
 token) ‚Üí erreur.

 üî• Les guillemets d√©sactivent le r√¥le sp√©cial des op√©rateurs (>, <, |, etc.).

üéØ Ton lexer doit savoir lire une cha√Æne enti√®re entre " " ou ' ' comme un seul mot.

<infile.txt cat >outfile.txt | cat >outfile2.txt, 
le pipe ne recoit rien car redirection out avant


	si 2 commandes dans un seul pipe -> error
    Si une redirection est pr√©sente sans fichier ‚Üí erreur ( < ou > )

    Si | est en d√©but ou fin ‚Üí erreur

    Si une commande est vide (ex : | |) ‚Üí erreur


	pour lexer enlever les redirections et le mot suivant la redirection qui peut etre coller
	et potentillement directement le coller dans execve


	pour les pipes commencer par une commande simple SANS PIPE pour commencer

	if (cmd_has_input_redirection)
    dup2(fd_input, 0);
else if (has_prev_pipe)
    dup2(prev_pipe_read, 0);

if (cmd_has_output_redirection)
    dup2(fd_output, 1);
else if (has_next_pipe)
    dup2(next_pipe_write, 1);


ft_exit("Cannot allocate memory\n", all, 12); quand malloc echoue


si pipe tout built in dans enfant aucune exception !!




HERDOC: CAT << STOP""
$USER
STOP

la variable user ne doit pas etre expand car ""

SHLVL ne peut pas depasser 1000

echo $USER,$rveve,12$USER ok $ $123 $!??USER $'USER' $US'ER' '$USER'


--------il faudra encore ajouter le $?-------- 
echo ~ doit expand variable home
echo ~/srtjykuyfutytyejryu

sans pipe on lance chaque commande dans un enfant
	pour ne pas execve dans le parent

--------il faudra encore ajouter le $?-------- 
echo ~ doit expand variable home
echo ~/srtjykuyfutytyejryu

sans pipe on lance chaque commande dans un enfant
	pour ne pas execve dans le parent


echo cou | | echo ok
echo cou "| |" echo ok
echo cou "|"
echo ">out"
>out <in echo ok
Voici le tableau compl√©t√© avec la diff√©rence entre **parent** (shell principal) et **enfant** (processus fork√©, ex‚ÄØ: dans un pipe)‚ÄØ:

| Commande           | Affiche "exit" | Message d‚Äôerreur                  | Quitte le shell principal | Quitte le process enfant | Code de sortie |
|--------------------|:--------------:|-----------------------------------|:------------------------:|:-----------------------:|:--------------:|
| `exit`             | oui (parent)   | non                               | oui                      | oui                     |   `$?`         |
|                    | non (enfant)   | non                               | non                      | oui                     |   `$?`         |
| `exit 42`          | oui (parent)   | non                               | oui                      | oui                     |   42           |
|                    | non (enfant)   | non                               | non                      | oui                     |   42           |
| `exit abc`         | oui (parent)   | oui (numeric required)            | oui                      | oui                     |   2            |
|                    | non (enfant)   | oui (numeric required)            | non                      | oui                     |   2            |
| `exit 1 2`         | oui (parent)   | oui (too many arguments)          | non                      | oui                     |   1            |
|                    | non (enfant)   | oui (too many arguments)          | non                      | oui                     |   1            |
| `exit abc 2`       | oui (parent)   | oui (numeric required)            | oui                      | oui                     |   2            |
|                    | non (enfant)   | oui (numeric required)            | non                      | oui                     |   2            |
| `exit 1 abc`       | oui (parent)   | oui (too many arguments)          | non                      | oui                     |   1            |
|                    | non (enfant)   | oui (too many arguments)          | non                      | oui                     |   1            |

**R√©sum√©**‚ÄØ:
- **Parent**‚ÄØ: affiche "exit", quitte le shell principal (sauf "too many arguments")
- **Enfant**‚ÄØ: ne doit pas afficher "exit", quitte juste le process enfant (jamais le shell principal)
- Les messages d‚Äôerreur sont toujours affich√©s (sur stderr) dans les deux cas